
public class TreeNavigator {

	/**
	 * The <CODE>TreeNode</CODE> that is the start of the entire tree.
	 */
	private TreeNode root = new TreeNode();
	
	/**
	 * The <CODE>TreeNode</CODE> that a user can interact with, and use to navigate throughout the tree,
	 *  without replacing other <CODE>TreeNode</CODE>s. This reference is set to the <CODE>root</CODE> by default.
	 */
	private TreeNode cursor = root;

	private TreeNode anything;
	/**
	 * Returns a tree after reading a string
	 * @param treeFile
	 * The <CODE>String</CODE> parameter to be read and interpreted as a tree.
	 * <dt><b>Preconditions:</b>
	 * <dd><CODE>treeFile</CODE> is a non-null, non-empty String that points to a file that exists,
	 *  that is readable and valid.
	 * @return
	 * The return value is a new <CODE>TreeNavigator</CODE> generated by reading the <CODE>treeFile</CODE>.
	 */
	public static TreeNavigator buildTree(String treeFile)
	{
		if (treeFile != null)
		{
			TreeNavigator answer = new TreeNavigator();
			String[] newFile = treeFile.split("\n");
			for(int i = 0; i < newFile.length; i++)
			{
					String[] part = newFile[i].split(";");
					answer.editCursor(part[1]);
					if(part[0].endsWith("0"))
					{
						answer.cursorLeft();
					}
					else if(part[0].endsWith("1"))
					{
						answer.cursorRight();
					}
			}
			return answer;
		}
		else
			throw new IllegalArgumentException("Tree File is null.");
	}

	/**
	 * Classifies the text with the given tree and returns the classification as a <CODE>String</CODE>.
	 * @param text
	 * The user entered text that will be used to search for a specific node
	 * @return
	 * The return value is a <CODE>String</CODE>, representing the <CODE>keywords</CODE> of the node that will satisfy the user input.
	 */
	public String classify(String text)
	{
		String answer = "";
		TreeNode tempCursor = root;
		//Test if it is contains a keyword

		while(!tempCursor.isLeaf())
		{
			for(int x = 0; x < tempCursor.getKeywords().length; x++)
			{
				if(text.contains(tempCursor.getKeywords()[x]))
				{
					if(tempCursor.getRight() != null)
						tempCursor = tempCursor.getRight();
				}
				else
				{
					if(tempCursor.getLeft() != null)
						tempCursor = tempCursor.getLeft();
				}
			}
		}
		answer += tempCursor.toString();
		anything = tempCursor;
		return answer;
	}

	public TreeNode getAnything()
	{
		return anything;
	}
	
	/**
	 * Gets the current path of the <CODE>cursor</CODE>.
	 * 
	 * @return
	 * The return value is the decision path in which from the root, to the <CODE>cursor</CODE>, and all the steps that were taken.
	 */
	public String getPath()
	{
		String path = "Decision path: ";
		String answer = " DECISION: " + getCursor().toString();
		int i = 0;
		int x = 0;
		
		TreeNode tempCursor = getCursor();
		while(tempCursor.getParent() != root && tempCursor.getParent() != null)
		{
			tempCursor = tempCursor.getParent();
			i++;
		}
			
		String[] backwardsPath = new String[i+1];
		tempCursor = getCursor();
		
		while(tempCursor.getParent() != null)
		{
			if(tempCursor.getParent().getLeft() == tempCursor)
			{
				tempCursor = tempCursor.getParent();
				backwardsPath[x] = " NOT " + tempCursor.toString();
				x++;
			}
			
			else if(tempCursor.getParent().getRight() == tempCursor)
			{
				tempCursor = tempCursor.getParent();
				backwardsPath[x] = " IS " + tempCursor.toString();
				x++;
			}
		}
		
		for (int j = (backwardsPath.length - 1); j >= 0; j--)
		{
			if(backwardsPath != null)
				path += backwardsPath[j];
		}
		return path + answer;	
	}

	/**
	 * Resets <CODE>cursor</CODE> to the <CODE>root</CODE> node.
	 * <dt><b>Postconditions:</b>
	 * <dd><CODE>Cursor</CODE> references <CODE>root</CODE> node. Cursor contents are printed.
	 */
	public void resetCursor()
	{
		cursor = root;
		System.out.println("Cursor moved. Cursor is at root.");
		
			if(cursor.getKeywords() != null)
				System.out.println("Current node keywords: " + cursor.toString());
			else
			{
				System.out.print("Current node keywords: " + cursor.toString());
			}
	}

	/**
	 * Moves <CODE>cursor</CODE> to its <CODE>left</CODE> child node.
	 * <dt><b>Postconditions:</b>
	 * <dd><CODE>Cursor<CODE> contents are printed.
	 */
	public void cursorLeft()
	{
			cursor = cursor.getLeft();
	}

	/**
	 * Moves <CODE>cursor</CODE> to its <CODE>right</CODE> child node.
	 * <dt><b>Postconditions:</b>
	 * <dd><CODE>Cursor<CODE> contents are printed.
	 */
	public void cursorRight()
	{
			cursor = cursor.getRight();
	}
	
	public void cursorParent()
	{
		if(cursor.getParent() != null)
			cursor = cursor.getParent();
	}

	/**
	 * This gets the <CODE>cursor</CODE> so you can modify the <CODE>keywords</CODE>, the <CODE>left</CODE> node, or the <CODE>right</CODE> nodes.
	 * <dt><b>Preconditions:</b>
	 * <dd><CODE>Cursor</CODE> is not null.
	 * <dt><b>Postconditions:</b>
	 * <dd><CODE>Cursor</CODE> is returned to the caller.
	 * @return
	 * The return value is the <CODE>TreeNode</CODE> referenced by the <CODE>cursor</CODE>.
	 */
	public TreeNode getCursor()
	{
		if(cursor == null)
			return null;
		return cursor;
	}

	/**
	 * <CODE>cursor</CODE> mutator method
	 * @param newCursor
	 * The new <CODE>TreeNode</CODE> to be set as the <CODE>cursor</CODE>.
	 */
	public void setCursor(TreeNode newCursor)
	{
		cursor = newCursor;
	}
	/**
	 * Sets the <CODE>keywords</CODE> for the current <CODE>cursor</CODE>.
	 * @param text
	 * The text that would be inserted as <CODE>keywords</CODE>, separated each by commas.
	 */
	public void editCursor(String text)
	{
		String[] blah = text.split(",");			
		cursor.setKeywords(blah);
	}
	/**
	 * <CODE>root</CODE> accessor method
	 * @return
	 * The return value is the <CODE>root</CODE> field.
	 */
	public TreeNode getRoot()
	{
		if(root == null)
			return null;
		return root;
	}
}
